#!usr/bin/env python3
#from sympy import symbols, Eq
#seed = 211286818345627549183608678726370412218029639873054513839005340650674982169404937862395980568550063504804783328450267566224937880641772833325018028629959635
#m, c, n -> (s*m +c)%n
#m,c,n,s = symbols('m,c,n,s')
#a1,a2,a3,a4,a5,a6 = symbols('a1,a2,a3,a4,a5,a6')
#k1,k2,k3,k4,k5,k6 = symbols('k1,k2,k3,k4,k5,k6')
#eq1 = Eq(s*m + c,   k1+a1*n)
#eq2 = Eq(s*m*m + c*m + c,   k2+a2*n)
#eq3 = Eq(s*m*m*m + c*m*m + c*m + c,   k3+a3*n)
#eq4 = Eq(s*m*m*m*m + c*m*m*m + c*m*m + c*m + c ,   k4+a4*n)
#eq5 = Eq(s*m*m*m*m*m + c*m*m*m*m + c*m*m*m + c*m*m + c*m + c,   k5+a5*n)
#eq6 = Eq(s*m*m*m*m*m*m + c*m*m*m*m*m +c*m*m*m*m + c*m*m*m + c*m*m + c*m +c ,   k6+a6*n)



import sys
import math
import random
from pwn import *
import functools

def calc_det(i,j,X):
    """ Calculate the values for the matrix[lattice] """
    a1 = X[i] - X[0]
    b1 = X[i+1] - X[1]
    a2 = X[j] - X[0]
    b2 = X[j+1] - X[1]

    """ Calculate the determinant """
    det = a1*b2 - a2*b1
    return abs(det)

def GCD(a,b):
    """ Euclidean Algo"""
    a = abs(a)
    b = abs(b)
    while a:
            a,b = (b%a),a
    return b

def modInverse(a, m):

    if GCD(a, m) != 1:
        return None # no mod inverse if a & m aren't relatively prime

    u1, u2, u3 = 1, 0, a
    v1, v2, v3 = 0, 1, m
    while v3 != 0:
        q = u3 // v3 # // is the integer division operator
        v1, v2, v3, u1, u2, u3 = (u1 - q * v1), (u2 - q * v2), (u3 - q * v3), v1, v2, v3
    return u1 % m

def mnc(seq):
    while True:
        try:
            X = seq
            
            Det_X = []
            Det_X.append(calc_det(1,2,X))
            #print Det_X
            Det_X.append(calc_det(2,3,X))
            #print Det_X
            Det_X.append(calc_det(3,4,X))
            #print Det_X
            Det_X.append(calc_det(4,5,X))
            #print Det_X

            found_p = functools.reduce(GCD, Det_X)

            # To find 'a' and 'c' we need to solve the simple equation:
            #   a = ((x3 - x4)*INVERSE_MODULE((x2-x3),p))%p
            # And:
            # c = (x4 - a*x3)%p
            # Where x2, x3, x4 are all numbers generated by the LCG that we got already!

            mod_inv_a = modInverse((X[2]-X[3]), found_p) # Here we find the modular inverse of x2-x3 with modulo p
            found_a = ((X[3] - X[4])*mod_inv_a)%found_p
            #print (found_a) #found_a will be the correct a with high probability.

            found_c = (X[4] - found_a*X[3])%found_p
            #print (found_c) #found_c will be the correct a with high probability, clearly depending on the correctness of a

            #print ("Found: %d as P(n), %d as a(m) and %d as c" % (found_p, found_a, found_c))
            return {'n':found_p, 'm':found_a, 'c':found_c}
            break
        except TypeError:
            break

if __name__ == "__main__":
    seq = [3731043939854257221999830474817480032517098829649730137423456396218668619924951972173654976988351037211387082982005253759427685622235541152068070506490930,
        11730937158300231488626025798133728219979806356796809037784007779342165799809627416567413344300815634238956601620121269301546312321426051969661483253419567,
        2973304500975440763628683228497540644727472497422880716087005634846535498851786566577087586549530903047148626582384339645702974217054024231079179407799574,
        13401068006582832848833478003511482056928305166605799387498444586228447106781707202037512843003137741177728163718438304617919311153726509255809669392589211,
        3167106789957690049093050635063137185173169376492445573592589051048471780231775894075110829279589385873650152836415750692968407781764266970301545782402458,
        12858643214494650321245059489606485221048833067047309448803672201701274610064773262718120733212218618937653116900580227180706728695154080654979143772975591,
        12135321621116444996127565693436773562451814930403401175333470855500864961674970127396070867746233544026554445786139296136084271476800881428291667080689342]
    sys.exit(mnc(seq))